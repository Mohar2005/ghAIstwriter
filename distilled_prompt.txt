Here is a quick Hypothesis strategies reference.

```python
from hypothesis.strategies import DataObject, DrawFn
from typing import Callable, Tuple

def binary(min_size: int = 0, max_size: int = None) -> bytes: ...
def booleans() -> bool: ...
def builds(target: Callable, /, *args, **kwargs) -> object: ... # Use ... to infer strategy from optional args.
def characters(
    *,
    codec=None,
    min_codepoint: int = None,
    max_codepoint: int = None,
    categories: Tuple[str, ...] = None,
    exclude_categories: Tuple[str, ...] = None,
    exclude_characters: str = None,
    include_characters: str = None,
) -> str: ...
def complex_numbers(
    min_magnitude: float = 0,
    max_magnitude: float = None,
    allow_infinity: bool = None,
    allow_nan: bool = None,
    allow_subnormal: bool = True,
    width: int = 128,
) -> complex: ...
def composite(f: Callable[[DrawFn], ...]) -> ...: ... # The first argument of f must be `draw`.
def data() -> DataObject: ...
def dates(
    min_value: datetime.date = datetime.date.min,
    max_value: datetime.date = datetime.date.max,
) -> datetime.date: ...
def datetimes(
    min_value: datetime.datetime = datetime.datetime.min,
    max_value: datetime.datetime = datetime.datetime.max,
    *,
    timezones=none(),
    allow_imaginary: bool = True,
) -> datetime.datetime: ...
def decimals(
    min_value=None,
    max_value=None,
    *,
    allow_nan: bool = None,
    allow_infinity: bool = None,
    places: int = None,
) -> decimal.Decimal: ...
def deferred(definition: Callable[[], ...]) -> ...: ...
def dictionaries(
    keys, values, *, dict_class: type = dict, min_size: int = 0, max_size: int = None
) -> dict: ...
def emails(domains=...) -> str: ...
def fixed_dictionaries(mapping, *, optional=None) -> dict: ...
def floats(
    min_value: float = None,
    max_value: float = None,
    *,
    allow_nan: bool = None,
    allow_infinity: bool = None,
    allow_subnormal: bool = None,
    width: int = 64,
    exclude_min: bool = False,
    exclude_max: bool = False,
) -> float: ...
def fractions(
    min_value=None, max_value=None, *, max_denominator: int = None
) -> fractions.Fraction: ...
def from_regex(regex, *, fullmatch: bool = False, alphabet: str = None) -> str | bytes: ...
def from_type(thing: type) -> ...: ...
def frozensets(elements, *, min_size: int = 0, max_size: int = None) -> frozenset: ...
def functions(
    *,
    like: Callable = lambda: ...,
    returns=...,
    pure: bool = False
) -> Callable: ...
def integers(min_value: int = None, max_value: int = None) -> int: ...
def ip_addresses(v: int = None, network=None) -> ipaddress.IPv4Address | ipaddress.IPv6Address: ...
def iterables(
    elements, *, min_size: int = 0, max_size: int = None, unique_by=None, unique: bool = False
) -> ...: ...
def just(value) -> ...: ...
def lists(
    elements, *, min_size: int = 0, max_size: int = None, unique_by=None, unique: bool = False
) -> list: ...
def none() -> None: ...
def nothing() -> ...: ... # Never draws a value.
def one_of(*args) -> ...: ...
def permutations(values) -> list: ...
def random_module() -> ...: ...
def randoms(note_method_calls: bool = False, use_true_random: bool = False) -> random.Random: ...
def recursive(base, extend: Callable, *, max_leaves: int = 100) -> ...: ...
def register_type_strategy(custom_type, strategy) -> None: ...
def runner(*, default=...) -> ...: ...
def sampled_from(elements) -> ...: ...
def sets(elements, *, min_size: int = 0, max_size: int = None) -> set: ...
def shared(base, *, key=None) -> ...: ...
def slices(size: int) -> slice: ...
def text(
    alphabet=characters(codec="utf-8"), *, min_size: int = 0, max_size: int = None
) -> str: ...
def timedeltas(
    min_value: datetime.timedelta = datetime.timedelta.min,
    max_value: datetime.timedelta = datetime.timedelta.max,
) -> datetime.timedelta: ...
def times(
    min_value: datetime.time = datetime.time.min,
    max_value: datetime.time = datetime.time.max,
    *,
    timezones=none(),
) -> datetime.time: ...
def timezone_keys(*, allow_prefix: bool = True) -> str: ...
def timezones(*, no_cache: bool = False) -> zoneinfo.ZoneInfo: ...
def tuples(*args) -> tuple: ...
def uuids(*, version: int = None, allow_nil: bool = False) -> uuid.UUID: ...
```
